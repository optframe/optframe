// ============================================
// Main.cpp file generated by OptFrame
// Project open-pit-mining operational planning
// ============================================

#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <iomanip>

#include "../OptFrame/Heuristics/EvolutionaryAlgorithms/ES.hpp"
#include "../OptFrame/Heuristics/Empty.hpp"
#include "./OPM/NSEnumLD.hpp"
#include "./OPM.h"

using namespace std;
using namespace optframe;
using namespace POLAD;

int main(int argc, char **argv)
{
	long seed = time(NULL); //CalibrationMode
	//seed = 2;
	cout << "Seed = " << seed << endl;
	srand(seed);
	RandGen rg(seed);

	if (argc != 6)
	{
		cout << "Parametros incorretos!" << endl;
		cout << "Os parametros esperados sao: instance time targetObj batchOfTheSameInstance ESMutationRate";
		exit(1);
	}

	const char* caminho = argv[1];
	double tempo = atof(argv[2]);
	double fo_alvo = atof(argv[3]);
	int batch = atoi(argv[4]);
	double mutationRate = atof(argv[5]);

	string nome = caminho;

	cout << "Parametros:" << endl;
	cout << "nome=" << nome << endl;
	cout << "tempo=" << tempo << endl;
	cout << "fo_alvo=" << fo_alvo << endl;
	cout << "batch=" << batch << endl;
	cout << "seed=" << seed << endl;
	cout << "mutationRate=" << mutationRate << endl;

	Scanner scanner(new File(nome + ".dat"));

	size_t found = nome.find_last_of("/\\");
	string instanceName = nome.substr(found + 1);
	stringstream ss;
	ss << "./OPM/Results/" << instanceName;
	string outputFile = ss.str();
//	cout << outputFile << endl;
//	getchar();

	OPMProblemInstance opm(scanner);
	OPMEvaluator eval(opm);
	OPMInitialSolutionGreedyRandomized greedy(opm, rg);
	NSEnumLD* ns_ld = new NSEnumLD(opm, rg);
	NSEnumNT* ns_nt = new NSEnumNT(opm, rg);
	NSEnumPO* ns_po = new NSEnumPO(opm, rg);
	NSEnumSS* ns_ss = new NSEnumSS(opm, rg);
	NSEnumST* ns_st = new NSEnumST(opm, rg);
	NSEnumTO* ns_to = new NSEnumTO(opm, rg);
	NSEnumTP* ns_tp = new NSEnumTP(opm, rg);
	NSEnumTT* ns_tt = new NSEnumTT(opm, rg);

	EmptyLocalSearch<RepOPM> emptyLS;
	vector<NSSeq<RepOPM>*> vNSeq;
	vNSeq.push_back(ns_ld);
	vNSeq.push_back(ns_nt);
	vNSeq.push_back(ns_po);
	vNSeq.push_back(ns_ss);
	vNSeq.push_back(ns_st);
	vNSeq.push_back(ns_to);
	vNSeq.push_back(ns_tp);
	vNSeq.push_back(ns_tt);

	vector<int> vNSeqMaxApplication(vNSeq.size(), 15);

	int selectionType = 1;
	//mutationRate = 1;
	ES<RepOPM> es(eval, greedy, vNSeq, vNSeqMaxApplication, emptyLS, selectionType, mutationRate, rg, 100, 600, 30000, outputFile, batch);

	pair<Solution<RepOPM>&, Evaluation&>* finalSol;
	finalSol = es.search(tempo);

	//ES es(opm, nome, eval, seed, 100, 600, 50000, outputFile, batch); // mi, lambda, geracoes
	//s = es.search(s, tempo, fo_alvo);

	finalSol->first.print();
	finalSol->second.print();

	FILE* arquivo = fopen("./Results/log.txt", "a");
	if (!arquivo)
	{
		cout << "ERRO: falha ao criar arquivo \"./Results/log.txt\"" << endl;
	}
	else
	{
		fprintf(arquivo, "%s\t%f\t%f\t%ld\n", instanceName.c_str(), mutationRate, finalSol->second.evaluation(),seed);
		fclose(arquivo);
	}

//	OPMSolCheck(opm, s);

	cout << "Program ended successfully";

	return 0;
}
