// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================

#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <numeric>
#include <string>
#include "../../../OptFrame/RandGen.hpp"
#include "../../../OptFrame/Util/RandGenMersenneTwister.hpp"

using namespace std;
using namespace optframe;
using namespace HFM;

int HFM_API(int argc, char **argv)
{
	cout << "=============================================================" << endl;
	cout << "Welcome to the Hybrid Metaheuristic Fuzzy Model API!" << endl;
	cout << "Interface is on the way to go... :)" << endl;
	cout << "=============================================================" << endl;
	RandGenMersenneTwister rg;
	long seed = time(nullptr); //CalibrationMode
	cout << "Seed = " << seed << endl;
	srand(seed);
	rg.setSeed(seed);

	int option = 1;
	vector<string> explanatoryVariables;

	while (option != 0)
	{
		cout << "Please choose your action:" << endl;
		cout << "1 - change current seed." << endl;
		cout << "2 - add problem historical time-series." << endl;
		cout << "3 - clear historical time-series." << endl;
		cout << "4 - define problem pameters (training/validation/forecasting horizon)." << endl;
		cout << "5 - load hybrid model" << endl;
		cin >> option;
		switch (option)
		{
		case 1:
			cout << "Please type new seed" << endl;
			cin >> seed;
			cout << "Current Seed = " << seed << "\n \n";
			break;

		case 2:
		{

			cout << "Please type instance path:" << endl;

			string nome;
			cin >> nome;
			cout << "You are trying to read the following path:" << nome << endl;
			cout << "Is it right? (1 or 0) " << endl;
			int right;
			cin >> right;

			if (right == 1)
				explanatoryVariables.push_back(nome);

			cout << explanatoryVariables << endl;
		}
			break;

		case 3:
		{
			cout << "Cleanning explanatory variables..." << endl;
			explanatoryVariables.clear();
		}
			break;

		case 4:
		{
			ProblemParameters problemParam;
			cout << "Please type forecasting horizon:" << endl;
			int nSA;
			cin >> nSA;
			cout << "Forecasting horizonte set to be:" << nSA << endl;
			problemParam.setStepsAhead(nSA);

			cout << "Please type maximum LAG to be used:" << endl;
			int maxLag;
			cin >> maxLag;
			cout << "Maximum lag is:" << maxLag << endl;
			problemParam.setMaxLag(maxLag);

		}
			break;

		case 5:
		{
			treatForecasts rF(explanatoryVariables);

			HFMParams methodParam;
			cout << "Please type Evolution Strategy Pop Size (offpring = 6*mu):" << endl;
			int mu;
			cin >> mu;
			methodParam.setESMU(mu);
			methodParam.setESLambda(6 * mu);

			methodParam.setESMaxG(100000);

			//seting up Construtive params
			methodParam.setConstrutiveMethod(2);

			cout << "Please type constructive ACF limit:" << endl;
			double alphaACF;
			cin >> alphaACF;
			vector<double> vAlphaACFlimits;
			vAlphaACFlimits.push_back(alphaACF);
			methodParam.setConstrutiveLimitAlphaACF(vAlphaACFlimits);
			cout << "Please type constructive maximum number of rules (single/average/derivative):" << endl;
			double numberRules;
			cin >> numberRules;
			methodParam.setConstrutivePrecision(numberRules);

			double initialDesv = 10;
			double mutationDesv = 20;
			methodParam.setESInitialDesv(initialDesv);
			methodParam.setESMutationDesv(mutationDesv);

			//seting up Eval params
			cout << "Please type FO minizer (0 - MAPE \n 1- PINBAL \n 2- MSE...):" << endl;
			int evalFOMinimizer;
			cin >> evalFOMinimizer;
			methodParam.setEvalFOMinimizer(evalFOMinimizer);

			cout << "Please type approximation (0 for no approx) otherwise, 1,2,3,4,5:" << endl;
			int evalAprox;
			cin >> evalAprox;
			methodParam.setEvalAprox(evalAprox);

		}
			break;

		default:
			return 1;

		}
	}

	return 1;
//long  1412730737
}
