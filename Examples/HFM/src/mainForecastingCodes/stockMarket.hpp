#ifndef HFM_STOCK_MARKET_FORECASTING_HPP_
#define HFM_STOCK_MARKET_FORECASTING_HPP_

// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================

#include <OptFrame/RandGen.hpp>
#include <OptFrame/Util/RandGenMersenneTwister.hpp>
#include <iomanip>
#include <iostream>
#include <math.h>
#include <numeric>
#include <stdlib.h>
//#include "../../BBV/BBVTolls.hpp"

using namespace std;
using namespace optframe;
using namespace HFM;
extern int nThreads;

int
stockMarketForecasting(int argc, char** argv)
{
   nThreads = 1;
   cout << "Welcome to stock market forecasting!" << endl;
   cout << "Let's optimize with " << nThreads << " nThreads\n"
        << endl;

   RandGenMersenneTwister rg;
   //long  1412730737
   long seed = time(nullptr); //CalibrationMode
   seed = 1;
   cout << "Seed = " << seed << endl;
   srand(seed);
   rg.setSeed(seed);

   //	if (argc != 2)
   //	{
   //		cout << "Parametros incorretos!" << endl;
   //		cout << "Os parametros esperados sao: stockMarketTimeSeries" << endl;
   //		exit(1);
   //	}

   //	const char* caminhoOutput = argv[1];
   //	string nomeOutput = caminhoOutput;

   //===================================
   cout << "Parametros:" << endl;

   //Numero de passos a frente - Horizonte de previsao
   int fh = 1;
   //O valor mais antigo que pode ser utilizado como entrada do modelo de previsao [100]
   double argvMaxLagRate = 10;

   vector<string> explanatoryVariables;

   explanatoryVariables.push_back("./Instance/stockData/stockData");
   /*	explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigor");
	explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigorExp1");
	explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigorExp2");
	explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigorExp3");
	explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigorExp4");*/

   cout << "Variables and explanation:" << explanatoryVariables << endl;

   treatForecasts rF(explanatoryVariables);

   //Parametros do metodo
   int mu = 100;
   /////int mu = 1000;
   int lambda = mu * 6;
   int evalFOMinimizer = MAPE_INDEX;
   int contructiveNumberOfColumns = 100;
   cout << "contructiveNumberOfColumns:" << contructiveNumberOfColumns << endl;
   int evalAprox = 0;
   double alphaACF = -1;
   int construtive = 2;
   // ============ END FORCES ======================

   // ============= METHOD PARAMETERS=================
   HFMParams methodParam;
   //seting up ES params
   methodParam.setESMU(mu);
   methodParam.setESLambda(lambda);
   methodParam.setESMaxG(10000);

   //seting up ACF construtive params
   methodParam.setConstrutiveMethod(construtive);
   methodParam.setConstrutivePrecision(contructiveNumberOfColumns);
   vector<double> vAlphaACFlimits;
   for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
      vAlphaACFlimits.push_back(alphaACF);
   methodParam.setConstrutiveLimitAlphaACF(vAlphaACFlimits);

   //seting up Eval params
   methodParam.setEvalAprox(evalAprox);
   methodParam.setEvalFOMinimizer(evalFOMinimizer);
   // ==========================================

   // ================== READ FILE ============== CONSTRUTIVE 0 AND 1
   ProblemParameters problemParam(explanatoryVariables.size());
   //ProblemParameters problemParam(vParametersFiles[randomParametersFiles]);

   problemParam.setStepsAhead(fh);

   int nTotalForecastingsTrainningSet = rF.getForecastsSize(0) - fh;

   //========SET PROBLEM MAXIMUM LAG ===============
   cout << "argvMaxLagRate = " << argvMaxLagRate << endl;

   int maxLargAccordingToRate = ((nTotalForecastingsTrainningSet - fh) * argvMaxLagRate) / 100.0;
   maxLargAccordingToRate = ceil(maxLargAccordingToRate);
   if (maxLargAccordingToRate > (nTotalForecastingsTrainningSet - fh))
      maxLargAccordingToRate--;
   if (maxLargAccordingToRate <= 0)
      maxLargAccordingToRate = 1;

   cout << "maxLargAccordingToRate:" << maxLargAccordingToRate << endl;
   for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
      problemParam.setMaxLag(maxLargAccordingToRate, expVar);

   //If maxUpperLag is greater than 0 model uses predicted data: ( t - (-K) ) => (t + K) | K !=0
   for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
      problemParam.setMaxUpperLag(expVar, expVar);

   //	problemParam.setForceSampleLearningWithEndogenous(true, 1);
   //	problemParam.setForceSampleLearningWithEndogenous(true, 2);
   //	problemParam.setForceSampleLearningWithEndogenous(true, 3);
   problemParam.setForceSampleLearningWithEndogenous(true);

   //	problemParam.setForceSampleLearningWithEndogenous(true, 4);

   int maxLag = problemParam.getMaxLag(0);

   //int maxUpperLag = problemParam.getMaxUpperLag();
   //=================================================

   problemParam.setToRoundedForecasts(true);
   //	problemParam.setToNonNegativeForecasts(true);
   //	problemParam.setToBinaryForecasts(true);

   vector<double> foIndicators;
   int beginTrainingSet = 0;
   cout << std::setprecision(9);
   cout << std::fixed;
   double NTRaprox = (nTotalForecastingsTrainningSet - maxLag) / double(fh);
   cout << "#timeSeriesSize: " << rF.getForecastsSize(0) << endl;
   cout << "#nTotalForecastingsTrainningSet: " << nTotalForecastingsTrainningSet << endl;
   cout << "BeginTrainninningSet: " << beginTrainingSet << endl;
   cout << "#~NTR: " << NTRaprox << endl;
   cout << "#maxNotUsed: " << maxLag << endl;
   cout << "#StepsAhead: " << fh << endl
        << endl;

   vector<vector<double>> trainningSet; // trainningSetVector
   for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
      trainningSet.push_back(rF.getPartsForecastsEndToBegin(expVar, fh, nTotalForecastingsTrainningSet));

   //Pareto <SolutionHFM> *pf = new Pareto<SolutionHFM>();

   op<Pareto<EMSolutionHFM>> opf = std::nullopt;

   //ForecastClass* forecastObject;
   int timeES = 60;
   int timeGPLS = 60;
   int nBatches = 2;
   for (int b = 0; b < nBatches; b++) {
      if (b == 1)
         methodParam.setEvalFOMinimizer(MAPE_INV_INDEX);
      //forecastObject = new ForecastClass(trainningSet, problemParam, rg, methodParam);
      ForecastClass forecastObj(trainningSet, problemParam, rg, methodParam);
      op<ESolutionHFM> sol = forecastObj.run(timeES, 0, 0);
      //		pair<Solution<RepEFP, OPTFRAME_DEFAULT_ADS>, Evaluation<>>* sol = forecastObject->runGILS(0, timeES);
      //		cout << "Bye bye..see u soon." << endl;
      //		exit(1);

      forecastObj.addSolToParetoWithParetoManager(*opf, sol->first);
      //Pareto<SolutionHFM> pfNew = forecastObj.runMultiObjSearch(timeGPLS, pf);
      //delete pf;
      //pf = pfNew;
      forecastObj.runMultiObjSearch(timeGPLS, opf);
      //delete forecastObject;
      ////delete sol;

      //		getchar();
   }

   //forecastObject = new ForecastClass(trainningSet, problemParam, rg, methodParam);
   ForecastClass forecastObj(trainningSet, problemParam, rg, methodParam);

   vector<MultiEvaluation<>*> vEvalPF = opf->getParetoFrontPtr();
   //vector<SolutionHFM*> vSolPF = pf->getParetoSet();
   vector<EMSolutionHFM*> vESolPF = opf->getParetoSetFrontPtr();
   int nObtainedParetoSol = vEvalPF.size();

   vector<vector<double>> dataForFeedingValidationTest;
   for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
      dataForFeedingValidationTest.push_back(rF.getPartsForecastsEndToBegin(expVar, fh, maxLag));

   int targetFile = problemParam.getTargetFile();
   vector<double> targetValidationSet;
   targetValidationSet = rF.getPartsForecastsEndToBegin(targetFile, 0, fh);

   //Using Multi Round forecasting for obtaining validation and tests
   //	vector<vector<double> > validationSet;
   //	for (int expVar = 0; expVar < (int) explanatoryVariables.size(); expVar++)
   //		validationSet.push_back(rF.getPartsForecastsEndToBegin(expVar, 0, fh + maxLag));

   vector<vector<double>*> ensembleBlindForecasts;
   cout << "\nPrinting obtained sets of predicted values..." << endl;
   for (int i = 0; i < nObtainedParetoSol; i++) {
      cout << setprecision(2);
      vector<double>* blindForecasts = forecastObj.returnBlind(vESolPF[i]->first.getR(), dataForFeedingValidationTest);
      for (int f = 0; f < (int)blindForecasts->size(); f++)
         cout << blindForecasts->at(f) << "/" << targetValidationSet.at(f) << "/" << (targetValidationSet.at(f) - blindForecasts->at(f)) << "\t";

      cout << endl;

      //		cout << forecastObject->returnForecastsAndTargets(vSolPF[i]->getR(), validationSet) << endl;
      //		getchar();
      ensembleBlindForecasts.push_back(blindForecasts);
      //getchar();
   }

   cout << "\nPrinting pareto front forecast accuracy measures..." << endl;
   for (int i = 0; i < nObtainedParetoSol; i++) {
      cout << setprecision(5);
      for (int e = 0; e < (int)vEvalPF[i]->size(); e++)
         cout << vEvalPF[i]->at(e).getObjFunction() << "\t\t";
      cout << endl;
   }

   opf->exportParetoFront("./Outputs/paretoFrontGPLS.txt", "w");

   //delete pf;
   //delete forecastObject;

   for (int i = 0; i < nObtainedParetoSol; i++)
      delete ensembleBlindForecasts[i];

   cout << "MO Stock Market forecasting finished!" << endl;

   //	===========================================
   //	TIME FOR BRINCANDO COM A BOLSA DE VALORES (BBV)
   //	BBVTools bbvTools;

   return 0;
}

#endif /*HFM_STOCK_MARKET_FORECASTING_HPP_*/
