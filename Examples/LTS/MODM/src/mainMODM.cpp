// SPDX-License-Identifier: LGPL-3.0-or-later OR MIT
// Copyright (C) 2007-2024 - OptFrame - https://github.com/optframe/optframe

// ===================================
// Main.cpp file generated by OptFrame
// Project MODM
// ===================================

// C
#include <math.h>
#include <stdlib.h>
// C++
#include <iostream>
#include <string>

//
#include <OptFrame/printable/printable.hpp>
using namespace optframe;
//

#include <OptFrame/Core/Evaluator.hpp>
#include <OptFrame/Helper/Solutions/ESolution.hpp>  // TODO: remove.. just to enforce compilation errors.
#include <OptFrame/Hyper/Loader.hpp>

#include "MODM/Evaluator.h"
// #include "../OptFrame/Heuristics/VNS/MOVNSLevels.hpp"
// #include "../OptFrame/Heuristics/2PPLS.hpp"
#include <OptFrame/Pareto/MultiEvaluator.hpp>
#include <OptFrame/Search/MultiObjSearch.hpp>
// #include "../OptFrame/Util/UnionNDSets.hpp"

#include <OptFrame/Helper/ConstructiveToInitialSearch.hpp>
#include <OptFrame/Pareto/MultiEvaluator.hpp>

#include "MODM/MODM.h"
#include "OptFrame/Heuristics/GRASP/GRConstructive.hpp"
#include "OptFrame/Heuristics/GRASP/GRInitialPopulation.hpp"

using namespace std;
using namespace optframe;
using namespace MODM;

char* execCommand(const char* command) {
  FILE* fp;
  char* line = NULL;
  // Following initialization is equivalent to char* result = ""; and just
  // initializes result to an empty string, only it works with
  // -Werror=write-strings and is so much less clear.
  char* result = (char*)calloc(1, 1);
  size_t len = 0;

  fflush(NULL);
  fp = popen(command, "r");
  if (fp == NULL) {
    printf("Cannot execute command:\n%s\n", command);
    return NULL;
  }

  while (getline(&line, &len, fp) != -1) {
    // +1 below to allow room for null terminator.
    result = (char*)realloc(result, strlen(result) + strlen(line) + 1);
    // +1 below so we copy the final null terminator.
    strncpy(result + strlen(result), line, strlen(line) + 1);
    free(line);
    line = NULL;
  }

  fflush(fp);
  if (pclose(fp) != 0) {
    perror("Cannot close stream.\n");
  }

  return result;
}

double hipervolume(std::vector<vector<double>> v) {
  int nSol = v.size();
  int nObj = v[0].size();
  string tempFile = "tempFileHipervolueFunc";
  FILE* fTempHV = fopen(tempFile.c_str(), "w");

  for (int s = 0; s < nSol; s++) {
    for (int o = 0; o < nObj; o++) {
      fprintf(fTempHV, "%.7f\t", v[s][o]);
    }
    fprintf(fTempHV, "\n");
  }

  fclose(fTempHV);
  std::stringstream ss;
  ss << "./hv\t -r \"" << 0 << " " << 0 << "\" \t" << tempFile.c_str();
  string hvValueString = execCommand(ss.str().c_str());
  double hvValue = atof(hvValueString.c_str());
  return hvValue;
}

int main(int argc, char** argv) {
  int nOfArguments = 7;
  if (argc != (1 + nOfArguments)) {
    std::cout << "Parametros incorretos!" << std::endl;
    std::cout
        << "Os parametros esperados sao: \n"
           "1 - instancia \n"
           "2 - saida - for saving solutions for each execution - type write\n"
           "3 - saida geral -- general file for savings all results - type "
           "append \n"
           "4 - timeILS\n"
           "5 - alpha Builder Int\n"
           "6 - alpha NS Int \n"
           "7 - initial population size \n"
        << std::endl;
    exit(1);
  }

  // RandGenMersenneTwister rg;
  sref<RandGen> rg{new RandGenMersenneTwister()};
  long seed = time(NULL);

  // seed = 10;
  srand(seed);
  rg->setSeed(seed);

  const char* instancia = argv[1];
  const char* saida = argv[2];
  const char* saidaGeral = argv[3];
  int timeILS = atoi(argv[4]);
  int alphaBuilderInt = atoi(argv[5]);
  int alphaNSInt = atoi(argv[6]);
  int pop = atoi(argv[7]);

  double alphaBuilder = alphaBuilderInt / 10.0;
  double alphaNeighARProduct = alphaNSInt / 10.0;

  string filename = instancia;
  string output = saida;
  string outputGeral = saidaGeral;
  std::cout << "filename = " << filename << std::endl;
  std::cout << "output = " << output << std::endl;
  std::cout << "outputGeral = " << outputGeral << std::endl;
  std::cout << "timeILS = " << timeILS << std::endl;
  std::cout << "alphaBuilder = " << alphaBuilder << std::endl;
  std::cout << "alphaNeighARProduct = " << alphaNeighARProduct << std::endl;
  std::cout << "initial population size = " << pop << std::endl;
  std::cout << "Seed = " << seed << std::endl;

  // filename = "./MyProjects/MODM/Instances/S3-15/S3-10-15-1-s.txt";
  // filename = "./MyProjects/MODM/Instances/L-5/L-10-5-1-l.txt";

  // string filename = "./MyProjects/MODM/Instances/L-5/L-15-5-2-s.txt";

  File file{filename};

  if (!file.isOpen()) {
    std::cout << "File '" << filename << "' not found" << std::endl;
    return false;
  }

  Scanner scanner{std::move(file)};

  ProblemInstance p{scanner};

  // add everything to the HeuristicFactory 'hf'

  MODMADSManager adsMan(p);
  MODMEvaluator eval(p, adsMan);
  sref<Evaluator<SolutionMODM, EvaluationMODM, ESolutionMODM>> sref_eval{
      new MODMEvaluator(p, adsMan)};
  sref<GeneralEvaluator<ESolutionMODM>> geval{new MODMEvaluator{p, adsMan}};

  //
  MODMRobustnessEvaluator evalRobustness(p, adsMan, rg);
  sref<Evaluator<SolutionMODM, EvaluationMODM, ESolutionMODM>>
      sref_evalRobustness{new MODMRobustnessEvaluator(p, adsMan, rg)};

  ConstructiveBasicGreedyRandomized grC(p, rg, adsMan);

  sref<GRConstructive<SolutionMODM>> grC2{
      new ConstructiveBasicGreedyRandomized{p, rg, adsMan}};

  ConstructiveToInitialSearch<ESolutionMODM> is_grC(grC, eval);

  sref<InitialSearch<ESolutionMODM>> is_grC2{
      new ConstructiveToInitialSearch<ESolutionMODM>(grC, eval)};

  // NSSeqSWAP nsseq_swap(rg, &p);
  sref<NSSeq<ESolutionMODM>> nsseq_swap{new NSSeqSWAP(rg, &p)};
  // NSSeqSWAPInter nsseq_swapInter(rg, &p);
  sref<NSSeq<ESolutionMODM>> nsseq_swapInter{new NSSeqSWAPInter(rg, &p)};
  // NSSeqInvert nsseq_invert(rg, &p);
  sref<NSSeq<ESolutionMODM>> nsseq_invert{new NSSeqInvert(rg, &p)};
  // NSSeqARProduct nsseq_arProduct(rg, &p, alphaNeighARProduct);
  sref<NSSeq<ESolutionMODM>> nsseq_arProduct{
      new NSSeqARProduct(rg, &p, alphaNeighARProduct)};
  // NSSeqADD nsseq_add(rg, &p);
  sref<NSSeq<ESolutionMODM>> nsseq_add{new NSSeqADD(rg, &p)};

  // ================ BEGIN OF CHECK MODULE ================

  /*	CheckCommand<SolutionMODM> check(false);
         check.add(grC);
         check.add(eval);
         //check.add(nsseq_swap);
         //check.add(nsseq_swapInter);
         check.add(nsseq_invert);
         //check.add(nsseq_arProduct);

         check.run(1, 1);
         getchar();*/

  // ================ END OF CHECK MODULE ================
  FI<ESolutionMODM> fiSwap(geval, nsseq_swap);
  FI<ESolutionMODM> fiSwapInter(geval, nsseq_swapInter);
  FI<ESolutionMODM> fiInvert(geval, nsseq_invert);

  int nMovesRDM = 500000;
  RDM<ESolutionMODM> rdmSwap(geval, nsseq_swap, nMovesRDM);
  RDM<ESolutionMODM> rdmSwapInter(geval, nsseq_swapInter, nMovesRDM);
  RDM<ESolutionMODM> rdmInvert(geval, nsseq_invert, nMovesRDM);
  RDM<ESolutionMODM> rdmARProduct(geval, nsseq_arProduct, nMovesRDM);
  RDM<ESolutionMODM> rdmADD(geval, nsseq_add, 1);

  // vector<LocalSearch<ESolutionMODM>*> vLS;
  //
  vsref<LocalSearch<ESolutionMODM>> vLS;
  //
  // vLS.push_back(&fiSwap);
  // vLS.push_back(&fiSwapInter);
  // vLS.push_back(&fiInvert);

  vLS.push_back(&rdmSwap);
  vLS.push_back(&rdmSwapInter);
  // vLS.push_back(&rdmInvert);
  vLS.push_back(&rdmADD);

  // vLS.push_back(&rdmARProduct);

  VND<ESolutionMODM> vnd(geval, vLS);
  sref<LocalSearch<ESolutionMODM>> vnd2{new VND<ESolutionMODM>(geval, vLS)};

  // ILSLPerturbationLPlus2<SolutionMODM> ilsl_pert(eval, 100000, nsseq_invert,
  // rg);
  Evaluator<SolutionMODM, EvaluationMODM, ESolutionMODM>& eval2 = eval;

  auto ilsl_pert =
      new ILSLPerturbationLPlus2<ESolutionMODM>(geval, nsseq_arProduct, rg);
  // ILSLPerturbationLPlus2<SolutionMODM> ilsl_pert(eval, 100000, nsseq_add,
  // rg);
  ilsl_pert->add_ns(nsseq_add);
  ilsl_pert->add_ns(nsseq_swapInter);
  ilsl_pert->add_ns(nsseq_swap);
  ilsl_pert->add_ns(nsseq_invert);

  sref<optframe::ILSLPerturbation<ESolutionMODM>> ilsl_pert2{ilsl_pert};

  ILSL<ESolutionMODM> ils(geval, is_grC2, vnd2, ilsl_pert2, 50, 15);
  ils.setMessageLevel(modlog::LogLevel::Info);

  pair<Solution<SolutionMODM>&, Evaluation<>&>* finalSol;

  EmptyLS<ESolutionMODM> emptyLS;
  sref<LocalSearch<ESolutionMODM>> emptyLS2{new EmptyLS<ESolutionMODM>{}};

  BasicGRASP<ESolutionMODM> g(geval, grC2, emptyLS2, alphaBuilder, 100000);

  g.setMessageLevel(modlog::LogLevel::Info);
  int timeGRASP = 100;
  double target = 9999999;
  // MODMProblemCommand problemCommand(rg);
  // finalSol = g.search(timeGRASP,target);

  //===========================================
  // MO
  // vector<Evaluator<SolutionMODM, EvaluationMODM, ESolutionMODM>*> v_e;
  vsref<Evaluator<SolutionMODM, EvaluationMODM, ESolutionMODM>> v_e;
  // v_e.push_back(&eval);
  v_e.push_back(sref_eval);
  // v_e.push_back(&evalRobustness);
  v_e.push_back(sref_evalRobustness);

  //	NSSeqSWAP nsseq_swap(rg, &p);
  //	NSSeqSWAPInter nsseq_swapInter(rg, &p);
  //	NSSeqInvert nsseq_invert(rg, &p);
  //	NSSeqARProduct nsseq_arProduct(rg, &p, alphaNeighARProduct);
  //	NSSeqADD nsseq_add(rg, &p);
  //
  // vector<NSSeq<ESolutionMODM>*> neighboors;
  //
  vsref<NSSeq<ESolutionMODM>> neighboors;

  neighboors.push_back(nsseq_arProduct);
  neighboors.push_back(nsseq_add);
  // neighboors.push_back(&nsseq_swapInter);
  // neighboors.push_back(&nsseq_swap);

  // alphaBuilder as the limit

  GRInitialPopulation<SolutionMODM> bip(grC, rg, 0.2);
  int initial_population_size = pop;
  initial_population_size = 10;
  MultiEvaluator<ESolutionMODM, EMSolutionMODM> mev(v_e);

  // MOVNSLevels (??) - TwoPhaseParetoLocalSearch (???) - Where is it Vitor?
  /*
        MOVNSLevels<SolutionMODM> multiobjectvns(v_e, bip,
     initial_population_size, neighboors, rg, 10, 10);
        TwoPhaseParetoLocalSearch<SolutionMODM> paretoSearch(mev, bip,
     initial_population_size, neighboors);

   */
  Pareto<EMSolutionMODM>* pf;
  /*
        int time2PPLS = 120;
        for (int exec = 0; exec < 1; exec++)
        {


                pf = paretoSearch.search(time2PPLS, 0);
                pf = multiobjectvns.search(300, 0);
        }
   */

  // 2PPLS (???)
  // UnionNDSets (???)
  /*

cout<<"Oi"<<endl;
getchar();
        UnionNDSets<SolutionMODM> US(v_e);
        vector<vector<double> > PF1 = US.unionSets("./paretoCorsTesteS3-1",
291);

        vector<vector<double> > PF2 = US.unionSets("./paretoCorsTesteS3-2",
262); vector<vector<double> > ref = US.unionSets(PF1, PF2);
        vector<vector<double> > refMin = ref;

        std::cout << PF1.size() << std::endl;
        std::cout << PF2.size() << std::endl;
        std::cout << ref.size() << std::endl;
//	getchar();
        std::cout << "Reference set" << std::endl;
        for (int p = 0; p < ref.size(); p++)
        {
                std::cout << ref[p][0] << "\t" << ref[p][1] << std::endl;
                refMin[p][0]*=-1;
                refMin[p][1]*=-1;
        }

   */

  //
  //	getchar();

  // How to get these to compile??

  /*

        vector<vector<Evaluation<>*> > vEval = pf->getParetoFront();
        vector<Solution<SolutionMODM>*> vSolPf = pf->getParetoSet();

        int nObtainedParetoSol = vEval.size();
        vector<vector<double> > paretoDoubleEval;
        vector<vector<double> > paretoDoubleEvalMin;

        std::cout << "MO optimization finished! Printing Pareto Front!" <<
     std::endl; for (int i = 0; i < nObtainedParetoSol; i++)
        {

                Solution<SolutionMODM>* sol = vSolPf[i];

                const RepMODM& rep = sol->getR();
                const AdsMODM& ads = sol->getADS();
                vector<double> solEvaluations;
                double foProfit = vEval[i][0]->getObjFunction();
                double foVolatility = vEval[i][1]->getObjFunction();
                solEvaluations.push_back(foProfit);
                solEvaluations.push_back(foVolatility);
                paretoDoubleEval.push_back(solEvaluations);
                solEvaluations[0] *= -1;
                solEvaluations[1] *= -1;
                paretoDoubleEvalMin.push_back(solEvaluations);

                vector<int> nPerCat =
     evalRobustness.checkNClientsPerCategory(rep, ads); std::cout << foProfit <<
     "\t"
     << foVolatility << "\t";

                int nTotalClients = nPerCat[nPerCat.size() - 1];

                for (int cat = 0; cat < 6; cat++)
                        std::cout << nPerCat[cat] << "\t";
                std::cout << std::endl;
        }

        int card = US.cardinalite(paretoDoubleEval, ref);
        double sCToRef = US.setCoverage(paretoDoubleEval, ref);
        double sCFromRef = US.setCoverage(ref, paretoDoubleEval);
        double hv = hipervolume(paretoDoubleEvalMin);

        vector<double> utopicSol;
        utopicSol.push_back(-5226);
        utopicSol.push_back(-10);
        double delta = US.deltaMetric(paretoDoubleEvalMin, utopicSol);

        //Delta Metric and Hipervolume need to verify min
        std::cout << "Cardinalite = " << card << std::endl;
        std::cout << "Set Coverage to ref = " << sCToRef << std::endl;
        std::cout << "Set Coverage from ref  = " << sCFromRef << std::endl;
        std::cout << "delta  = " << delta << std::endl;
        std::cout << "deltaRef  = " << US.deltaMetric(refMin, utopicSol) <<
     std::endl; std::cout << "hv  = " << hv << std::endl; std::cout << "ref  = "
     << hipervolume(refMin) << std::endl;

        FILE* fGeral = fopen(outputGeral.c_str(), "a");

        size_t pos = filename.find("Instances/");
        string instName = filename.substr(pos);

        fprintf(fGeral, "%s \t %d \t %.7f \t %.7f \t %d \t %d \t %.7f \t %.7f \t
     %.7f \t %.7f \t %ld \n", instName.c_str(), pop, alphaBuilder,
     alphaNeighARProduct, nObtainedParetoSol, card, sCToRef, sCFromRef, hv,
     delta, seed);

        fclose(fGeral);
*/

  // what else?

  // getchar();
  //===========================================

  /*
         //timeILS = 6;

         finalSol = ils.search(timeILS, target);

         std::cout << "ILS HAS ENDED!" << std::endl;
         finalSol->second.print();
         //finalSol->first.print();

         RepMODM repFinal = finalSol->first.getR();
         //finalSol = g.search(time,target);

         //cout << eval.getAverageTime() << std::endl;
         //cout << eval.getAverageTimeEvalComplete() << std::endl;

         double fo = finalSol->second.evaluation();
         int isFeasible = finalSol->second.isFeasible();

         FILE* fResults = fopen(output.c_str(), "w");

         fprintf(fResults, "%.7f \t %d \t%f\t%f\t %ld", fo, isFeasible,
     alphaBuilder, alphaNeighARProduct, seed); fprintf(fResults, "\n Solution");
         for (int c = 0; c < p.getNumberOfClients(); c++)
         {
         fprintf(fResults, "\n", fo, isFeasible);
         for (int product = 0; product < p.getNumberOfProducts(); product++)
         {
         fprintf(fResults, "%d\t", repFinal[c][product]);
         }
         }

         fprintf(fResults, "\n");

         fclose(fResults);

         FILE* fGeral = fopen(outputGeral.c_str(), "a");

         size_t pos = filename.find("Instances/");
         string instName = filename.substr(pos);

         fprintf(fGeral, "%s\t%.7f\t%d \t %f\t%f\t%ld\n", instName.c_str(), fo,
     isFeasible, alphaBuilder, alphaNeighARProduct, seed);

         fclose(fGeral);

         */
  std::cout << "Programa terminado com sucesso!" << std::endl;
  return 0;
}
