#ifndef HFM_STOCK_MARKET_FORECASTING_HPP_
#define HFM_STOCK_MARKET_FORECASTING_HPP_

// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================

#include <math.h>
#include <stdlib.h>

#include <OptFrame/Core/RandGen.hpp>
#include <OptFrame/Util/RandGenMersenneTwister.hpp>
#include <iomanip>
#include <iostream>
#include <numeric>
// #include "../../BBV/BBVTolls.hpp"

#include "../ForecastClass.hpp"

using namespace std;
using namespace optframe;
using namespace HFM;
extern int nThreads;

int stockMarketForecasting(int argc, char** argv) {
  nThreads = 1;
  std::cout << "Welcome to stock market forecasting!" << std::endl;
  std::cout << "Let's optimize with " << nThreads << " nThreads\n" << std::endl;

  RandGenMersenneTwister rg;
  sref<RandGen> rg2{new RandGenMersenneTwister{}};
  // long  1412730737
  long seed = time(nullptr);  // CalibrationMode
  seed = 1;
  std::cout << "Seed = " << seed << std::endl;
  srand(seed);
  rg.setSeed(seed);

  //	if (argc != 2)
  //	{
  //		cout << "Parametros incorretos!" << std::endl;
  //		cout << "Os parametros esperados sao: stockMarketTimeSeries" <<
  // endl; 		exit(1);
  //	}

  //	const char* caminhoOutput = argv[1];
  //	string nomeOutput = caminhoOutput;

  //===================================
  std::cout << "Parametros:" << std::endl;

  // Numero de passos a frente - Horizonte de previsao
  int fh = 1;
  // O valor mais antigo que pode ser utilizado como entrada do modelo de
  // previsao [100]
  double argvMaxLagRate = 10;

  vector<string> explanatoryVariables;

  explanatoryVariables.push_back("./Instance/stockData/stockData");
  /*	explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigor");
       explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigorExp1");
       explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigorExp2");
       explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigorExp3");
       explanatoryVariables.push_back("./Instance/dadosBovespa/emprestimoAigorExp4");*/

  std::cout << "Variables and explanation:" << explanatoryVariables
            << std::endl;

  treatForecasts rF(explanatoryVariables);

  // Parametros do metodo
  int mu = 100;
  /////int mu = 1000;
  int lambda = mu * 6;
  int evalFOMinimizer = MAPE_INDEX;
  int contructiveNumberOfColumns = 100;
  std::cout << "contructiveNumberOfColumns:" << contructiveNumberOfColumns
            << std::endl;
  int evalAprox = 0;
  double alphaACF = -1;
  int construtive = 2;
  // ============ END FORCES ======================

  // ============= METHOD PARAMETERS=================
  HFMParams methodParam;
  // seting up ES params
  methodParam.setESMU(mu);
  methodParam.setESLambda(lambda);
  methodParam.setESMaxG(10000);

  // seting up ACF construtive params
  methodParam.setConstrutiveMethod(construtive);
  methodParam.setConstrutivePrecision(contructiveNumberOfColumns);
  vector<double> vAlphaACFlimits;
  for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
    vAlphaACFlimits.push_back(alphaACF);
  methodParam.setConstrutiveLimitAlphaACF(vAlphaACFlimits);

  // seting up Eval params
  methodParam.setEvalAprox(evalAprox);
  methodParam.setEvalFOMinimizer(evalFOMinimizer);
  // ==========================================

  // ================== READ FILE ============== CONSTRUTIVE 0 AND 1
  ProblemParameters problemParam(explanatoryVariables.size());
  // ProblemParameters problemParam(vParametersFiles[randomParametersFiles]);

  problemParam.setStepsAhead(fh);

  int nTotalForecastingsTrainningSet = rF.getForecastsSize(0) - fh;

  //========SET PROBLEM MAXIMUM LAG ===============
  std::cout << "argvMaxLagRate = " << argvMaxLagRate << std::endl;

  int maxLargAccordingToRate =
      ((nTotalForecastingsTrainningSet - fh) * argvMaxLagRate) / 100.0;
  maxLargAccordingToRate = ceil(maxLargAccordingToRate);
  if (maxLargAccordingToRate > (nTotalForecastingsTrainningSet - fh))
    maxLargAccordingToRate--;
  if (maxLargAccordingToRate <= 0) maxLargAccordingToRate = 1;

  std::cout << "maxLargAccordingToRate:" << maxLargAccordingToRate << std::endl;
  for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
    problemParam.setMaxLag(maxLargAccordingToRate, expVar);

  // If maxUpperLag is greater than 0 model uses predicted data: ( t - (-K) ) =>
  // (t + K) | K !=0
  for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
    problemParam.setMaxUpperLag(expVar, expVar);

  //	problemParam.setForceSampleLearningWithEndogenous(true, 1);
  //	problemParam.setForceSampleLearningWithEndogenous(true, 2);
  //	problemParam.setForceSampleLearningWithEndogenous(true, 3);
  problemParam.setForceSampleLearningWithEndogenous(true);

  //	problemParam.setForceSampleLearningWithEndogenous(true, 4);

  int maxLag = problemParam.getMaxLag(0);

  // int maxUpperLag = problemParam.getMaxUpperLag();
  //=================================================

  problemParam.setToRoundedForecasts(true);
  //	problemParam.setToNonNegativeForecasts(true);
  //	problemParam.setToBinaryForecasts(true);

  vector<double> foIndicators;
  int beginTrainingSet = 0;
  std::cout << std::setprecision(9);
  std::cout << std::fixed;
  double NTRaprox = (nTotalForecastingsTrainningSet - maxLag) / double(fh);
  std::cout << "#timeSeriesSize: " << rF.getForecastsSize(0) << std::endl;
  std::cout << "#nTotalForecastingsTrainningSet: "
            << nTotalForecastingsTrainningSet << std::endl;
  std::cout << "BeginTrainninningSet: " << beginTrainingSet << std::endl;
  std::cout << "#~NTR: " << NTRaprox << std::endl;
  std::cout << "#maxNotUsed: " << maxLag << std::endl;
  std::cout << "#StepsAhead: " << fh << std::endl << std::endl;

  vector<vector<double>> trainningSet;  // trainningSetVector
  for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
    trainningSet.push_back(rF.getPartsForecastsEndToBegin(
        expVar, fh, nTotalForecastingsTrainningSet));

  // Pareto <SolutionHFM> *pf = new Pareto<SolutionHFM>();

  op<Pareto<EMSolutionHFM>> opf = std::nullopt;

  // ForecastClass* forecastObject;
  int timeES = 60;
  int timeGPLS = 60;
  int nBatches = 2;
  for (int b = 0; b < nBatches; b++) {
    if (b == 1) methodParam.setEvalFOMinimizer(MAPE_INV_INDEX);
    // forecastObject = new ForecastClass(trainningSet, problemParam, rg,
    // methodParam);
    ForecastClass forecastObj{trainningSet, problemParam, rg2, methodParam};
    op<ESolutionHFM> sol = forecastObj.run(timeES, 0, 0);
    //		pair<Solution<RepEFP, OPTFRAME_DEFAULT_ADS>, Evaluation<>>* sol
    //= forecastObject->runGILS(0, timeES); 		cout << "Bye bye..see u
    // soon." << endl; 		exit(1);

    forecastObj.addSolToParetoWithParetoManager(*opf, sol->first);
    // Pareto<SolutionHFM> pfNew = forecastObj.runMultiObjSearch(timeGPLS, pf);
    // delete pf;
    // pf = pfNew;
    forecastObj.runMultiObjSearch(timeGPLS, opf);
    // delete forecastObject;
    ////delete sol;

    //		getchar();
  }

  // forecastObject = new ForecastClass(trainningSet, problemParam, rg,
  // methodParam);
  ForecastClass forecastObj{trainningSet, problemParam, rg2, methodParam};

  vector<MultiEvaluation<>*> vEvalPF = opf->getParetoFrontPtr();
  // vector<SolutionHFM*> vSolPF = pf->getParetoSet();
  vector<EMSolutionHFM*> vESolPF = opf->getParetoSetFrontPtr();
  int nObtainedParetoSol = vEvalPF.size();

  vector<vector<double>> dataForFeedingValidationTest;
  for (int expVar = 0; expVar < (int)explanatoryVariables.size(); expVar++)
    dataForFeedingValidationTest.push_back(
        rF.getPartsForecastsEndToBegin(expVar, fh, maxLag));

  int targetFile = problemParam.getTargetFile();
  vector<double> targetValidationSet;
  targetValidationSet = rF.getPartsForecastsEndToBegin(targetFile, 0, fh);

  // Using Multi Round forecasting for obtaining validation and tests
  //	vector<vector<double> > validationSet;
  //	for (int expVar = 0; expVar < (int) explanatoryVariables.size();
  // expVar++)
  // validationSet.push_back(rF.getPartsForecastsEndToBegin(expVar, 0, fh +
  // maxLag));

  vector<vector<double>*> ensembleBlindForecasts;
  std::cout << "\nPrinting obtained sets of predicted values..." << std::endl;
  for (int i = 0; i < nObtainedParetoSol; i++) {
    std::cout << setprecision(2);
    vector<double>* blindForecasts = forecastObj.returnBlind(
        vESolPF[i]->first.getR(), dataForFeedingValidationTest);
    for (int f = 0; f < (int)blindForecasts->size(); f++)
      std::cout << blindForecasts->at(f) << "/" << targetValidationSet.at(f)
                << "/" << (targetValidationSet.at(f) - blindForecasts->at(f))
                << "\t";

    std::cout << std::endl;

    //		cout <<
    // forecastObject->returnForecastsAndTargets(vSolPF[i]->getR(),
    // validationSet) << std::endl; 		getchar();
    ensembleBlindForecasts.push_back(blindForecasts);
    // getchar();
  }

  std::cout << "\nPrinting pareto front forecast accuracy measures..."
            << std::endl;
  for (int i = 0; i < nObtainedParetoSol; i++) {
    std::cout << setprecision(5);
    for (int e = 0; e < (int)vEvalPF[i]->size(); e++)
      std::cout << vEvalPF[i]->at(e).getObjFunction() << "\t\t";
    std::cout << std::endl;
  }

  opf->exportParetoFront("./Outputs/paretoFrontGPLS.txt", "w");

  // delete pf;
  // delete forecastObject;

  for (int i = 0; i < nObtainedParetoSol; i++) delete ensembleBlindForecasts[i];

  std::cout << "MO Stock Market forecasting finished!" << std::endl;

  //	===========================================
  //	TIME FOR BRINCANDO COM A BOLSA DE VALORES (BBV)
  //	BBVTools bbvTools;

  return 0;
}

#endif /*HFM_STOCK_MARKET_FORECASTING_HPP_*/
