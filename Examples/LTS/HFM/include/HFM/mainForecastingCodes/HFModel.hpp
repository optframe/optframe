// ===================================
// Main.cpp file generated by OptFrame
// Project EFP
// ===================================

#include <math.h>
#include <stdlib.h>

#include <OptFrame/Core/RandGen.hpp>
#include <OptFrame/Util/RandGenMersenneTwister.hpp>
#include <iostream>
#include <numeric>
#include <string>

using namespace std;
using namespace optframe;
using namespace HFM;

int HFM_API(int argc, char** argv) {
  std::cout << "============================================================="
       << std::endl;
  std::cout << "Welcome to the Hybrid Metaheuristic Fuzzy Model API!" << std::endl;
  std::cout << "Interface is on the way to go... :)" << std::endl;
  std::cout << "============================================================="
       << std::endl;
  RandGenMersenneTwister rg;
  long seed = time(nullptr);  // CalibrationMode
  std::cout << "Seed = " << seed << std::endl;
  srand(seed);
  rg.setSeed(seed);

  int option = 1;
  vector<string> explanatoryVariables;

  while (option != 0) {
    std::cout << "Please choose your action:" << std::endl;
    std::cout << "1 - change current seed." << std::endl;
    std::cout << "2 - add problem historical time-series." << std::endl;
    std::cout << "3 - clear historical time-series." << std::endl;
    std::cout << "4 - define problem pameters (training/validation/forecasting "
            "horizon)."
         << std::endl;
    std::cout << "5 - load hybrid model" << std::endl;
    cin >> option;
    switch (option) {
      case 1:
        std::cout << "Please type new seed" << std::endl;
        cin >> seed;
        std::cout << "Current Seed = " << seed << "\n \n";
        break;

      case 2: {
        std::cout << "Please type instance path:" << std::endl;

        string nome;
        cin >> nome;
        std::cout << "You are trying to read the following path:" << nome << std::endl;
        std::cout << "Is it right? (1 or 0) " << std::endl;
        int right;
        cin >> right;

        if (right == 1) explanatoryVariables.push_back(nome);

        std::cout << explanatoryVariables << std::endl;
      } break;

      case 3: {
        std::cout << "Cleanning explanatory variables..." << std::endl;
        explanatoryVariables.clear();
      } break;

      case 4: {
        ProblemParameters problemParam;
        std::cout << "Please type forecasting horizon:" << std::endl;
        int nSA;
        cin >> nSA;
        std::cout << "Forecasting horizonte set to be:" << nSA << std::endl;
        problemParam.setStepsAhead(nSA);

        std::cout << "Please type maximum LAG to be used:" << std::endl;
        int maxLag;
        cin >> maxLag;
        std::cout << "Maximum lag is:" << maxLag << std::endl;
        problemParam.setMaxLag(maxLag);

      } break;

      case 5: {
        treatForecasts rF(explanatoryVariables);

        HFMParams methodParam;
        std::cout << "Please type Evolution Strategy Pop Size (offpring = 6*mu):"
             << std::endl;
        int mu;
        cin >> mu;
        methodParam.setESMU(mu);
        methodParam.setESLambda(6 * mu);

        methodParam.setESMaxG(100000);

        // seting up Construtive params
        methodParam.setConstrutiveMethod(2);

        std::cout << "Please type constructive ACF limit:" << std::endl;
        double alphaACF;
        cin >> alphaACF;
        vector<double> vAlphaACFlimits;
        vAlphaACFlimits.push_back(alphaACF);
        methodParam.setConstrutiveLimitAlphaACF(vAlphaACFlimits);
        std::cout << "Please type constructive maximum number of rules "
                "(single/average/derivative):"
             << std::endl;
        double numberRules;
        cin >> numberRules;
        methodParam.setConstrutivePrecision(numberRules);

        double initialDesv = 10;
        double mutationDesv = 20;
        methodParam.setESInitialDesv(initialDesv);
        methodParam.setESMutationDesv(mutationDesv);

        // seting up Eval params
        std::cout << "Please type FO minizer (0 - MAPE \n 1- PINBAL \n 2- MSE...):"
             << std::endl;
        int evalFOMinimizer;
        cin >> evalFOMinimizer;
        methodParam.setEvalFOMinimizer(evalFOMinimizer);

        std::cout << "Please type approximation (0 for no approx) otherwise, "
                "1,2,3,4,5:"
             << std::endl;
        int evalAprox;
        cin >> evalAprox;
        methodParam.setEvalAprox(evalAprox);

      } break;

      default:
        return 1;
    }
  }

  return 1;
  // long  1412730737
}
