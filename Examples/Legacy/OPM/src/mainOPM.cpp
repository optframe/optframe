// ============================================
// Main.cpp file generated by OptFrame
// Project open-pit-mining operational planning
// ============================================

#include <math.h>
#include <stdlib.h>

#include <iomanip>
#include <iostream>

// #include "./OPM.h"
// #include "./OPM/NSEnumLD.hpp"
#include <OptFrame/Heuristics/EvolutionaryAlgorithms/NGES.hpp>
#include <OptFrame/Heuristics/LocalSearches/EmptyLS.hpp>

#include "NSEnumLD.hpp"

using namespace std;
using namespace optframe;
using namespace POLAD;

int main(int argc, char** argv) {
  long seed = time(NULL);  // CalibrationMode
  // seed = 2;
  std::cout << "Seed = " << seed << std::endl;
  srand(seed);
  RandGen rg(seed);

  if (argc != 6) {
    std::cout << "Parametros incorretos!" << std::endl;
    std::cout << "Os parametros esperados sao: instance time targetObj "
                 "batchOfTheSameInstance ESMutationRate";
    exit(1);
  }

  const char* caminho = argv[1];
  double tempo = atof(argv[2]);
  double fo_alvo = atof(argv[3]);
  int batch = atoi(argv[4]);
  double mutationRate = atof(argv[5]);

  string nome = caminho;

  std::cout << "Parametros:" << std::endl;
  std::cout << "nome=" << nome << std::endl;
  std::cout << "tempo=" << tempo << std::endl;
  std::cout << "fo_alvo=" << fo_alvo << std::endl;
  std::cout << "batch=" << batch << std::endl;
  std::cout << "seed=" << seed << std::endl;
  std::cout << "mutationRate=" << mutationRate << std::endl;

  Scanner scanner(new File(nome + ".dat"));

  size_t found = nome.find_last_of("/\\");
  string instanceName = nome.substr(found + 1);
  std::stringstream ss;
  ss << "./OPM/Results/" << instanceName;
  string outputFile = ss.str();
  //	cout << outputFile << std::endl;
  //	getchar();

  OPMProblemInstance opm(scanner);
  OPMEvaluator eval(opm);
  OPMInitialSolutionGreedyRandomized greedy(opm, rg);
  NSEnumLD* ns_ld = new NSEnumLD(opm, rg);
  NSEnumNT* ns_nt = new NSEnumNT(opm, rg);
  NSEnumPO* ns_po = new NSEnumPO(opm, rg);
  NSEnumSS* ns_ss = new NSEnumSS(opm, rg);
  NSEnumST* ns_st = new NSEnumST(opm, rg);
  NSEnumTO* ns_to = new NSEnumTO(opm, rg);
  NSEnumTP* ns_tp = new NSEnumTP(opm, rg);
  NSEnumTT* ns_tt = new NSEnumTT(opm, rg);

  EmptyLS<RepOPM> emptyLS;
  vector<NSSeq<RepOPM>*> vNSeq;
  vNSeq.push_back(ns_ld);
  vNSeq.push_back(ns_nt);
  vNSeq.push_back(ns_po);
  vNSeq.push_back(ns_ss);
  vNSeq.push_back(ns_st);
  vNSeq.push_back(ns_to);
  vNSeq.push_back(ns_tp);
  vNSeq.push_back(ns_tt);

  vector<int> vNSeqMaxApplication(vNSeq.size(), 15);

  int selectionType = 1;
  // mutationRate = 1;
  ES<RepOPM> es(eval, greedy, vNSeq, vNSeqMaxApplication, emptyLS,
                selectionType, mutationRate, rg, 100, 600, 30000, outputFile,
                batch);

  pair<Solution<RepOPM>&, Evaluation<>&>* finalSol;
  finalSol = es.search(tempo);

  // ES es(opm, nome, eval, seed, 100, 600, 50000, outputFile, batch); // mi,
  // lambda, geracoes s = es.search(s, tempo, fo_alvo);

  finalSol->first.print();
  finalSol->second.print();

  FILE* arquivo = fopen("./Results/log.txt", "a");
  if (!arquivo) {
    std::cout << "ERRO: falha ao criar arquivo \"./Results/log.txt\""
              << std::endl;
  } else {
    fprintf(arquivo, "%s\t%f\t%f\t%ld\n", instanceName.c_str(), mutationRate,
            finalSol->second.evaluation(), seed);
    fclose(arquivo);
  }

  //	OPMSolCheck(opm, s);

  std::cout << "Program ended successfully";

  return 0;
}
